---
layout: article
title: "排序算法"
categories: algorithm
image:
  feature: spot.jpg
  teaser: spot.jpg
---

插入排序
算法描述：  
1. 取出一个数，称为锚数。算法中从位置为1的数开始（数组从位置0开始）  
2. 从该数开始依次往前扫描，遇到一个数比该数大，则换位置，扫描完成后，将0位置的数赋予锚数

```
//  C++
//
//  Created by lee on 29/08/2018.
//  Copyright © 2018 lee. All rights reserved.
//

#include <iostream>
#include <vector>
#include <string>
using namespace std;

void swap(int& a, int& b) {int tmp = a; a = b; b = tmp;}

// 插入排序
vector<int> insert_sort(vector<int>& A){
    for (auto i = 1; i < A.size(); i++){
        int key = A[i];
        int j = i;
        while ( j > 0 && A[j-1] > key){
            A[j] = A[j-1];
            j--;
        }
        A[j] = key;
    }
    return A;
}
int main(){
    vector<int> A = {9,8,5,3,3,3,3,3,1,7,2,1,4,6};
    cout << A.size()<<endl;
    bubble_sort(A);
    for (auto i : A){cout << i << " ";}
    cout << endl;
    return 0;
}

```

冒泡算法  
算法描述：  
1. 依次比较相邻的两个数，如果前一个数比第二个数大，则交换。
2. 重复第一步。  

```
//  C++
//
//  Created by lee on 29/08/2018.
//  Copyright © 2018 lee. All rights reserved.
//

#include <iostream>
#include <vector>
#include <string>
using namespace std;

void swap(int& a, int& b) {int tmp = a; a = b; b = tmp;}
//冒泡排序
void bubble_sort(vector<int>& A){
    for (auto i = 0; i < A.size()-1 ; i++)
        for (auto j = 0; j < A.size()-1-i; j++)
            if (A[j] > A[j+1])
                swap(A[j], A[j+1]);
}

int main(){
    vector<int> A = {9,8,5,3,3,3,3,3,1,7,2,1,4,6};
    cout << A.size()<<endl;
    bubble_sort(A);
    for (auto i : A){cout << i << " ";}
    cout << endl;
    return 0;
}
```

快速排序  
算法描述：	
以最后一个数为锚，将其前面的数按照，小于锚的数在其左边，大于锚的数在右边。

```
//  C++
//
//  Created by lee on 29/08/2018.
//  Copyright © 2018 lee. All rights reserved.
//

#include <iostream>
#include <vector>
#include <string>
using namespace std;

void swap(int& a, int& b) {int tmp = a; a = b; b = tmp;}
// 快速排序
int partition(vector<int>& A, int p, int r){
    // 必须用引用，否则该函数返回后，A的顺序不会发生变化
    int key = A[r];
    int i = p-1;
    for (auto j = p; j <= r-1; j++){
        if (A[j] <= key){
            i++;
            swap(A[i], A[j]);
        }
    }
    swap(A[i+1], A[r]);
    return i+1;
}

void quicksort(vector<int>& A, int p, int r){
    if (p < r){
        int q = partition(A, p, r);
        
        quicksort(A, p, q-1);
        quicksort(A, q+1, r);
    }
}
int main(){
    vector<int> A = {9,8,5,3,3,3,3,3,1,7,2,1,4,6};
    cout << A.size()<<endl;
    quicksort(A, 0, 13);
    for (auto i : A){cout << i << " ";}
    cout << endl;
    return 0;
}
```

||时间复杂度（平均）|时间复杂度（最坏）|空间复杂度|稳定性|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
插入排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定
冒泡排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定
快速排序|O(nlogn)|O(n<sup>2</sup>|O(nlogn)|不稳定

