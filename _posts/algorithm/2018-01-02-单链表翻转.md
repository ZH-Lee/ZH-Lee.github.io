---
layout: article
title: "单链表翻转"
categories: algorithm
image:
  feature: spot.jpg
  teaser: spot.jpg
---
相比之前的那个方法：[206. Reverse Linked List](http://blog.csdn.net/a173373310/article/details/77388568)
这个方法比较简单，直接在链表上面进行逆序
容易理解

此代码是用于将带头结点的单链表进行逆序，思路：
1.首先设p结点为第一个有效结点（即头结点的下一个节点），q为p的下一个节点，原因从后面可知。
2. 将所给节点从头结点处断开，然后让p结点的下一个连接到头结点，头结点的下一个连接到p，这就形成了一个节点的插入，然后由于q是原链表中p的下一个节点，所以使得p能找到原链表中下一个节点，q的作用就在此，后面就是循环加入。

```
//
//  反转单链表.cpp
//  反转单链表
//
//  Created by lee on 2018/10/20.
//  Copyright © 2018年 lee. All rights reserved.
//

#include <iostream>
using namespace std;

struct Node{
    int val;
    Node *next = NULL;
    Node(int x):val(x), next(NULL) {}
};

Node* reverseLinkedList(Node *head){
    Node *cur = head;
    Node *pre = NULL;
    while(cur != NULL){
        Node *next = cur->next;
        cur->next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
int main(int argc, const char * argv[]) {
    Node *n1 = new Node(1);
    Node *n2 = new Node(4);
    Node *n3 = new Node(8);
    Node *n4 = new Node(7);
    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    
    Node *it = n1;
    while (it != NULL){
        cout << it->val << " ";
        it = it->next;
    }
    cout << endl;
    
    Node *res = reverseLinkedList(n1);
    while (res != NULL){
        cout << res->val << " ";
        res = res->next;
    }
    cout << endl;
    return 0;
}```