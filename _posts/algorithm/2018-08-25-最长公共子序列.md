## 最长公共子序列
找出两个字符串中最长公共子序列。如S1 = "1B2C3A", S2 = "B12C3D"</br>
则最长公共子序列是: "12C3"或"B2C3"

解决算法：动态规划，空间复杂度：O(MN)
dp[i][j] 表示S1的第i个，S2的第j个位置之前，有多少个公共子字符串。（**关键**）

dp[0][0...N]表示用第二个字符串中的每个字符与第一字符串的相对应位置字符相比，如果相等，则为1，并且之后的所有都不需要再对比，直接赋值为1。如S1[0] = "1", S2[0...N] = "B12C3D"，则:  
dp[0][0] = 0 <br>
dp[0][1...N] = 1 <br>
这是因为，当一个字符得到匹配后，后面的字符串无论如何，都会至少包含这个字符，所以后面全部设为1。<br>

相对应的：<br>
dp[1...M][0]与上同理<br>

除了第一列和第一行，其他位置的元素由下列方法确定：  
**方法1**. 如果S1[i] != S2[j]: <br>
dp[i][j] = max(dp[i][j-1], dp[i-1][j]) <br>
**方法2**. 如果S1[i] == S2[j]: <br>
dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + 1<br>

以上完成了dp矩阵的构建，下面就要从dp矩阵中解析出最长公共子序列:<br>
遍历的方式是从右下角开始，从我们的dp定义就可以看出来，因为右下角的含义是最后一个元素之前，最长公共子序列的长度是多少。<br>

**用P代表当前位置，P不在代码中出现，只是为了方便说明<br>**

解析dp矩阵：

1. P指向右下角，若dp[i][j] > dp[i-1][j] && dp[i][j] > dp[i][j-1], 即如果该位置的数字同时大于其上、左的数字时，则表明，这个元素是通过**方法2**得到的，所以这个元素被放到输出列表。并且P往左上方移动<br>
2. 若dp[i][j] == dp[i-1][j], 即如果P所指的值等于其左的数字时，往左移动。
3. 若dp[i][j] == dp[i][j-1], 即如果P所指的值等于其上的数字时，往上移动。
4. 若P指向第一行或者第一列时，则取第一行或第一列第一个位置不为0的字符即可

若S1 = "1B2C3A", S2 = "B12C3D", 得到dp矩阵：(矩阵下方的文字代表该步记录了某个字符，然后跳到下一个矩阵)

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|4|4|

解析过程：<br>

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|4|<font color = #ff0000>4|

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|<font color = #ff0000>4|4|

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|<font color = #ff0000>4|4|
|A|1|1|2|3|4|4|
记录字符"3"<br>

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|<font color = #ff0000>3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|4|4|
记录字符"C"

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|1|1|1|1|1|
|2|1|1|<font color = #ff0000>2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|4|4|
记录字符"2"

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|1|<font color = #ff0000>1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|4|4|

| |B | 1 | 2 | C | 3 | D|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|0|1|1|1|1|1|
|B|<font color = #ff0000>1|1|1|1|1|1|
|2|1|1|2|2|2|2|
|C|1|1|2|3|3|3|
|3|1|1|2|3|4|4|
|A|1|1|2|3|4|4|
记录字符"B"

最大公共子序列可能不唯一，如本题可以是"12C3", 也可以是"B2C3"。取决于解析步骤2、3的顺序。<br>
最后翻转一下结果即可。<br>
C++代码如下：

```
//  C++
//
//  Created by lee on 25/08/2018.
//  Copyright © 2018 lee. All rights reserved.
//

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

string Longest_common_substring(string s1, string s2){
    string res;
    auto m = s1.size();
    auto n = s2.size();
    vector<vector<int>> dp(m, vector<int> (n,0));
    
    //Build dp matrix
    dp[0][0] = s1[0] == s2[0]?1:0;
    
    // The first row
    for (int i = 1; i < m; ++i){
        dp[i][0] = max(dp[i-1][0], s1[i] == s2[0]?1:0);
    }
    // The first col
    for (int j = 1; j < n; ++j){
        dp[0][j] = max(dp[0][j-1], s1[0] == s2[j]?1:0);
    }
    
    for (int i = 1; i < m; ++i){
        for (int j = 1; j < n; ++j){
            if (s1[i] == s2[j]){
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1;
            }
            else{
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    // Get max substring from dp matrix
    auto i = m-1;
    auto j = n-1;
    
    int Longest_common_substring_length = dp[i][j];
    
    while (Longest_common_substring_length > 0){
        if (dp[i][j] > dp[i-1][j] && dp[i][j] > dp[i][j-1]){
            res += s1[i];
            --i;
            --j;
            --Longest_common_substring_length;
        }
        else if (dp[i][j] == dp[i][j-1]){
            --j;
        }
        else{
            --i;
        }
        
    }
    
    reverse(res.begin(), res.end()); // reverse res string
    return res;
}

int main(int argc, const char * argv[]) {
    string s1 = "1B2C3A";
    string s2 = "B12C3D";
    string res;
    res = Longest_common_substring(s1, s2);
    cout << res << endl;
    return 0;
}

```

参考：左程云《程序员代码面试指南》